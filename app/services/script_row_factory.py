"""
ðŸ­ Script Row Factory â€” Factory functions para criaÃ§Ã£o de rows do roteiro.

ExtraÃ­do de script_generator.py em 09/Fev/2026 (refatoraÃ§Ã£o P2.1).

Centraliza a criaÃ§Ã£o de rows para eliminar duplicaÃ§Ã£o entre:
- _build_rows_from_edl()
- _build_rows_from_analysis()
- _build_rows_from_transcript_only()
- _build_rows_from_triage_only()

PrincÃ­pio: 1 lugar para definir a estrutura de um row.
Se precisar adicionar um campo novo, muda num lugar sÃ³.
"""

import uuid
from typing import Dict, List, Optional


def create_speech_row(
    asset_id: str,
    voice_text: str,
    order: int,
    filename: str = '',
    speaker: str = '',
    source_type: str = 'talking_head',
    notes: str = '',
    editorial_purpose: str = '',
) -> dict:
    """
    Cria um row de speech (transcriÃ§Ã£o / fala).
    
    Campos obrigatÃ³rios: asset_id, voice_text, order.
    Todos os outros sÃ£o opcionais com defaults razoÃ¡veis.
    """
    return {
        'id': f'row-{uuid.uuid4().hex[:8]}',
        'order': order,
        'voice': voice_text,
        'visual': '',
        'type': 'speech',
        'notes': notes,
        'sourceAssetId': asset_id,
        'sourceSpeaker': speaker,
        'sourceType': source_type,
        'editorialPurpose': editorial_purpose,
        'isAutoGenerated': True,
        'filename': filename,
        'textSource': 'transcribed',
    }


def create_broll_row(
    asset_id: str,
    visual_desc: str,
    order: int,
    filename: str = '',
    source_type: str = 'b_roll',
    notes: str = '',
) -> dict:
    """
    Cria um row de b-roll (info visual).
    """
    return {
        'id': f'row-{uuid.uuid4().hex[:8]}',
        'order': order,
        'voice': '',
        'visual': visual_desc,
        'type': 'broll_info',
        'notes': notes,
        'sourceAssetId': asset_id,
        'sourceType': source_type,
        'isAutoGenerated': True,
        'filename': filename,
        'textSource': 'transcribed',
    }


def attach_intra_retakes(
    row: dict,
    asset_id: str,
    intra_index: Dict[str, List[dict]],
) -> dict:
    """
    Anexa segmentos de intra-retakes ao row se existirem no index.
    Modifica o dict in-place e retorna.
    """
    if asset_id in intra_index:
        row['segments'] = intra_index[asset_id]
        row['hasIntraRetakes'] = True
    return row


def mark_as_retake_removed(
    row: dict,
    reason: str = '',
    kept_asset_id: str = '',
) -> dict:
    """
    Marca um row como retake removido (strikethrough no frontend).
    Modifica o dict in-place e retorna.
    """
    row['isRetakeRemoved'] = True
    row['retakeReason'] = reason
    row['retakeKeptAssetId'] = kept_asset_id
    return row


def create_single_segment_from_words(
    asset_id: str,
    words: List[dict],
) -> List[dict]:
    """
    Cria um ÃšNICO segmento cobrindo toda a transcriÃ§Ã£o.

    Usado quando nÃ£o hÃ¡ intra-retakes mas queremos que o editor
    tenha segmentos para suportar word-level diff (correÃ§Ãµes amarelas,
    deleÃ§Ãµes vermelhas riscadas).

    Sem segmentos, o editor usa contentEditable simples e deleÃ§Ãµes
    somem em vez de ficarem riscadas.
    """
    if not words:
        return []

    # Texto completo
    text = ' '.join(w.get('text', '') for w in words).strip()
    if not text:
        return []

    # Timestamps
    first = words[0]
    last = words[-1]

    start_s = first.get('start', 0)
    end_s = last.get('end', 0)

    # Normalizar ms para seconds
    if isinstance(start_s, (int, float)) and start_s > 1000:
        start_s = start_s / 1000.0
    if isinstance(end_s, (int, float)) and end_s > 1000:
        end_s = end_s / 1000.0

    return [{
        'id': f'seg-{uuid.uuid4().hex[:8]}',
        'start_s': float(start_s),
        'end_s': float(end_s),
        'text': text,
        'status': 'keep',
        'removedBy': None,
        'removedReason': '',
    }]


def create_title_row(
    title_result: dict,
    order: int = 0,
) -> dict:
    """
    Cria um row de tÃ­tulo sugerido para o editor de roteiro.

    O tÃ­tulo aparece como a primeira row do roteiro, acima de todo o conteÃºdo.
    Ã‰ editÃ¡vel pelo usuÃ¡rio.

    Args:
        title_result: Resultado do Title Director (com title, alternatives, style_suggestion)
        order: PosiÃ§Ã£o no roteiro (default 0 = primeiro)
    """
    title = title_result.get('title', {})
    line_1 = title.get('line_1', '')
    line_2 = title.get('line_2', '')
    full_text = title.get('full_text', f'{line_1} {line_2}'.strip())

    # Extrair png_style do style_suggestion (para ediÃ§Ã£o visual no frontend)
    style_suggestion = title_result.get('style_suggestion', {})
    png_style = style_suggestion.get('png_style', {})

    return {
        'id': f'title-{uuid.uuid4().hex[:8]}',
        'order': order,
        'voice': '',
        'visual': '',
        'type': 'title_suggestion',
        'titleLine1': line_1,
        'titleLine2': line_2,
        'titleFullText': full_text,
        'highlightWords': title.get('highlight_words', []),
        'styleSuggestion': style_suggestion,
        'pngStyle': png_style,
        'alternatives': title_result.get('alternatives', []),
        'source': title_result.get('source', 'transcript_analysis'),
        'rationale': title_result.get('rationale', ''),
        'isAutoGenerated': True,
        'editable': True,
        'removable': True,
    }


def index_vision_results(vision_result: Optional[dict]) -> Dict[str, dict]:
    """
    Indexa resultados do Vision Director por asset_id.
    
    Lida com ambos formatos:
    - videos: [{ asset_id: ... }, ...]
    - single result com status: 'success'
    """
    vision_videos: Dict[str, dict] = {}
    if not vision_result:
        return vision_videos

    videos = vision_result.get('videos', [])
    if not videos and vision_result.get('status') == 'success':
        videos = [vision_result]

    for v in videos:
        aid = v.get('asset_id', '')
        if aid:
            vision_videos[aid] = v

    return vision_videos
